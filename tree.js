//---------------------------------------//
// Variables
//---------------------------------------//
var rightContainer = document.getElementById("rightContainer");
var leftContainer = document.getElementById("leftContainer");
var width, height;
var treeRadius;
var nodeSize;

var previousK = 0;
var animationDuration = 400, zoomDuration = 150;
var lineGenerator;

var rightSVG;
var svgLinkGroup;
var svgNodeGroup;

var root, currentRoot;
var tree;



//---------------------------------------//
// Initialization
//---------------------------------------//
initHtmlElements();
setupD3Hierarchy();
setupD3Tree();

//collapse the tree to only show the currentRoot and it's children
currentRoot.children.forEach(collapseAllChildren);

window.addEventListener("resize", initTree);
initTree();

//---------------------------------------//
// Functions
//---------------------------------------//
function setupD3Hierarchy(){
  // create a d3 hierarchy from the data generated by generateRandomTree()
  root = d3.stratify()
    .id(function(d) { return d.name; }) //tells d3 where to find the id for each node
    .parentId(function(d) { return d.parent; }) //tells d3 where to find the id for each nodes parent node
    (generateRandomTree()); //passes the data to create the tree from
  
  currentRoot = root;
  currentRoot.x0 = width/2;
  currentRoot.y0 = height/2;
}

function setupD3Tree(){
  // create a new d3 tree
  tree = d3.tree()
          .separation( //defines how far nodes should be apart from each other
            function separation(a, b) {
              return (a.parent == b.parent ? .4 : 2) / a.depth;
            }
          );
}

function initHtmlElements(){
  // create an svg element and add it to the body
  rightSVG = d3.select(rightContainer).append("svg")
    .attr("width", "100%")
    .attr("height", "100%");

  // create group elements in the svg for links and nodes
  svgLinkGroup = rightSVG.append("g");
  svgNodeGroup = rightSVG.append("g");
}


function initTree(){
  width = rightContainer.offsetWidth; 
  height = rightContainer.offsetHeight;
  nodeSize = Math.min(width/10, height/10);
  treeRadius = height > width ? width/2 - nodeSize * 1.5 : height/2 - nodeSize * 1.5;
  updateTree();
}

function generateRandomTree(){
  var nodes = [{"name" : "0", "parent": "", "type" : 0, "text" : "Node 1"}];
  var currentNode = 0, currentNeighbor = 1, neighborCount, currentType;
  while(nodes.length < 400){
    neighborCount = 1 + Math.round(Math.random()*4);
    for (var i = 0; i < neighborCount; i++) {
      currentType = Math.round(Math.random())
      nodes.push({"name" : ""+currentNeighbor++, "parent" : currentNode, "type" : currentType, "text" : "Node " + (currentNeighbor)});
    }
    currentNode++;
  }
  return nodes;
}

//calculates where to put each node using the layout d3 came up with as polar coordinates
function calculateCoordinates(){
  currentRoot.descendants().forEach(function(current){
    var x = current.x;
    var y = current.y;
    current.x = Math.cos(x*2*Math.PI) * y * treeRadius + width / 2;
    current.y = Math.sin(x*2*Math.PI) * y * treeRadius + height / 2;
  })
  currentRoot.x = width / 2;
  currentRoot.y = height / 2;
}

//updates all the nodes and links when a zoom event has occured (zoom events also happen when dragging the tree around)
function zoomed() {
  if (d3.event.transform.k != previousK) {
    //zoom behaviour
    svgNodeGroup.transition()
      .duration(zoomDuration)
      .attr("transform", d3.event.transform);
    svgLinkGroup.transition()
      .duration(zoomDuration)
      .attr("transform", d3.event.transform);
  } else {
    //drag behaviour
    svgNodeGroup.attr("transform", d3.event.transform);
    svgLinkGroup.attr("transform", d3.event.transform);
  }
  previousK = d3.event.transform.k;
}

function nodeClicked(node){
  if (node.children) {
    collapseSingleNode(node);
    if(node.parent) currentRoot = node.parent;
  } else {
    if (node.childrenBackup) {
      currentRoot = node;
      node.children = node.childrenBackup;
    } else {
      return;
    }
  }
  updateTree();
}

function collapseSingleNode(node){
  if (node.children) {
    node.childrenBackup = node.children;
    node.children = null;
  }
}

function collapseAllChildren(node){
  if (node.children) {
    node.children.forEach(collapseAllChildren);
    collapseSingleNode(node);
  }
}

function calculateTextSize(d){
  var boundingBox = this.getBBox();
  var parentBox = this.parentNode.getBBox();
  d.fontSize = Math.min(parentBox.width / boundingBox.width, parentBox.height / boundingBox.height)*0.8 + "px";
}

//creates a line using d3.line() according to the links source and target
//always creates lines so they are drawn from left to right which makes sure
//that any text along the line will not be upside down
function getLine(link){
  if(link.source.x <= link.target.x){
    return lineGenerator([[link.source.x, link.source.y],[link.target.x, link.target.y]]);
  } else {
    return lineGenerator([[link.target.x, link.target.y],[link.source.x, link.source.y]]);
  } 
}

//decides the color of a node depending on its position in the tree
function getNodeColor(node){
  //leafs get white color
  if (!node.children && !node.childrenBackup) return "#fff";
  //the root gets red color
  if (node.id == currentRoot.id) return "#f00";
  //all other nodes get black color
  return "#000";
}

function updateTree(){

  //calculate a new layout for the tree
  tree(currentRoot);
  //convert coordinates of all nodes for radial layout
  calculateCoordinates();

  // add all the nodes from the tree as circles to the svg node Group
  var nodes = svgNodeGroup.selectAll("g").data(currentRoot.descendants(), function(d){return d.data.name});
  
  //transition existing nodes to their new positions
  nodes.transition()
      .duration(animationDuration)
      .attr("transform", function(d){
        return "translate(" + d.x + "," + d.y + ")"}
      )
      .attr("fill", getNodeColor);

  //update the sizes of existing nodes in case the screen size has changed
  nodes.each(function(d){
    if(d.data.type == 0){
      d3.select(this).select("circle").attr("r", nodeSize);
    } else if(d.data.type == 1){
      d3.select(this).select("ellipse").attr("rx", nodeSize).attr("ry", nodeSize);
    }
  });

  //update text sizes in case screen size has changed
  nodes.selectAll("text")
        .attr("font-size","1px")
        .each(calculateTextSize)
        .attr("font-size", function(d){return d.fontSize});

  //get all the nodes that have been added to the tree
  var newNodes = nodes.enter().append("g");
  
  //nodes that weren't in the tree before get a shape in the svg according to their type
  var newCircleNodes = newNodes.filter(function(d){
    return d.data.type == 0;
  });
  var newEllipseNodes = newNodes.filter(function(d){
    return d.data.type == 1;
  });
  newEllipseNodes.insert("ellipse")
              .attr("rx", nodeSize)
              .attr("ry", nodeSize * 0.6);
  newCircleNodes.insert("circle") 
            .attr("r", nodeSize);

  //nodes get text applied to them
  newNodes.insert("text")
          .text(function(d) {return d.data.text})
          .attr("text-anchor","middle")
          .attr("dominant-baseline", "central")
          .attr("font-size","1px")
          .each(calculateTextSize)
          .attr("font-size", function(d){return d.fontSize});

  //set the new nodes positions to their parents starting position
  newNodes.attr("transform", function(d){
    if(d.parent){
      d.x0 = d.parent.x;
      d.y0 = d.parent.y;
      return "translate(" + d.x0 + "," + d.y0 + ")";
    }
    else return "translate(" + d.x + "," + d.y + ")";
  })
  .attr("fill", getNodeColor)
  .attr("opacity", 0)
  //animate the node to go to it's correct position (starting from the parents previous position)
  .transition()
    .duration(animationDuration)
    .delay(animationDuration)
    .attr("transform", function(d){
      return "translate(" + d.x + "," + d.y + ")"}
    )
    .attr("opacity", 1);
  //remove nodes that aren't supposed to be shown anymore
  nodes.exit().remove();
  
  svgNodeGroup.selectAll("g").on("click", nodeClicked);

  // add all the links from the tree to the svg link group
  var links = svgLinkGroup.selectAll("path").data(currentRoot.links(), function(d){return d.target.id});
  
  //remove links that don't have a target anymore
  links.exit().remove();

  //create a new line generator
  if(!lineGenerator) lineGenerator = d3.line();

  //update existing links to their new coordinates
  links.transition().duration(animationDuration)
      .attr("d", getLine, lineGenerator, "asdf");//function(d){return lineGenerator([[d.source.x, d.source.y],[d.target.x, d.target.y]])});

  //give the new links a corresponding path in the svg and animate them
  links.enter().append("path")
      .attr("d", function(d){return lineGenerator([[d.source.x, d.source.y],[d.source.x, d.source.y]])})
      .attr("id", function(d){return d.source.id + "-" + d.target.id})
      .transition()
        .duration(animationDuration)
        .delay(animationDuration)
        .attr("d", getLine);

  //backup the current positions for animations
  nodes.each(function(d){
    d.x0 = d.x;
    d.y0 = d.y;
  });

  newNodes.each(function(d){
    d.x0 = d.x;
    d.y0 = d.y;
  });
}