var body = document.getElementsByTagName("body")[0];
var width = body.scrollWidth, height = body.scrollHeight;
var treeSize = height > width ? width/2 - 10 : height/2 - 10;
var centerX = width/2, centerY = height / 2;
var previousK = 0;

 // create an svg element and add it to the body
var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height)
    .call(
      d3.zoom()
        .on("zoom", zoomed)
        .scaleExtent([0.2,2])
    ); //adds a listener for zoom events (e.g. scrolling the mouse wheel). also handles dragging

// create group elements in the svg for links and nodes
var svgLinkGroup = svg.append("g");
var svgNodeGroup = svg.append("g");

// create a d3 hierarchy from the data generated by generateRandomTree()
var root = d3.stratify()
    .id(function(d) { return d.name; }) //tells d3 where to find the id for each node
    .parentId(function(d) { return d.parent; }) //tells d3 where to find the id for each nodes parent node
    (generateRandomTree()); //passes the data to create the tree from
root.x0 = width/2;
root.y0 = height/2;
// create a new d3 tree
var tree = d3.tree()
    .separation( //defines how far nodes should be apart from each other
      function separation(a, b) {
        return (a.parent == b.parent ? 2 : 3) / a.depth;
      });

//collapse the tree to only show the root and it's children
root.children.forEach(collapseAllChildren);

// tell the tree what data to use for it's nodes
updateTree();

//---------------------------------------//
// Functions
//---------------------------------------//

function generateRandomTree(){
  var nodes = [{"name" : "0", "parent": ""}];
  var currentNode = 0, currentNeighbor = 1, neighborCount;
  while(nodes.length < 200){
    neighborCount = 1 + Math.round(Math.random()*5);
    for (var i = 0; i < neighborCount; i++) {
      nodes.push({"name" : ""+currentNeighbor++, "parent" : currentNode});
    }
    currentNode++;
  }
  return nodes;
}

//calculates where to put each node using the layout d3 came up with as polar coordinates
function calculateCoordinates(){
  root.descendants().forEach(function(current){
    var x = current.x;
    var y = current.y;
    current.x = Math.cos(x*2*Math.PI) * y * treeSize + centerX,
    current.y = Math.sin(x*2*Math.PI) * y * treeSize + centerY;
  })
}

//updates all the nodes and links when a zoom event has occured (zoom events also happen when dragging the tree around)
function zoomed() {
  if (d3.event.transform.k != previousK) {
    //zoom behaviour
    svgNodeGroup.transition()
      .duration(150)
      .attr("transform", d3.event.transform);
    svgLinkGroup.transition()
      .duration(150)
      .attr("transform", d3.event.transform);
  } else {
    //drag behaviour
    svgNodeGroup.attr("transform", d3.event.transform);
    svgLinkGroup.attr("transform", d3.event.transform);
  }
  previousK = d3.event.transform.k;
}

function nodeClicked(node){
  if (node.children) {
    collapseSingleNode(node);
  } else {
    if (node.childrenBackup) {
      node.children = node.childrenBackup;
    } else {
      return;
    }
  }
  updateTree();
}

function collapseSingleNode(node){
  if (node.children) {
    node.childrenBackup = node.children;
    node.children = null;
  }
}

function collapseAllChildren(node){
  if (node.children) {
    node.children.forEach(collapseAllChildren);
    collapseSingleNode(node);
  }
}

function updateTree(){

  //calculate a new layout for the tree
  tree(root);
  //convert coordinates of all nodes for radial layout
  calculateCoordinates();

  // add all the nodes from the tree as circles to the svg node Group
  var nodes = svgNodeGroup.selectAll("circle").data(root.descendants(), function(d){return d.data.name});
  
  //transition existing nodes to their new positions
  nodes.transition()
      .duration(500)
      .attr("transform", function(d){
        return "translate(" + d.x + "," + d.y + ")"}
      );

  //nodes that weren't in the tree before get a circle in the svg
  var newNodes = nodes.enter();
      newNodes.append("circle")
      .attr("r", function(d){ 
        return 10 - d.depth 
      })
      //set the circles position to the parents starting position
      .attr("transform", function(d){
        if(d.parent){
          d.x0 = d.parent.x0;
          d.y0 = d.parent.y0;
          return "translate(" + d.x0 + "," + d.y0 + ")";
        }
        else return "translate(" + d.x + "," + d.y + ")";
      })
      //animate the circle to go to it's correct position (starting from the parents previous position)
      .transition()
        .duration(500)
        .attr("transform", function(d){
          return "translate(" + d.x + "," + d.y + ")"}
        );
  //remove nodes that aren't supposed to be shown anymore
  nodes.exit().remove();
  
  svgNodeGroup.selectAll("circle").on("click", nodeClicked);

  // add all the links from the tree to the svg link group
  var links = svgLinkGroup.selectAll("line").data(root.links(), function(d){return d.target.id});
  
  //remove links that don't have a target anymore
  links.exit().remove();

  //update existing links to their new coordinates
  links.transition().duration(500)
      .attr("x1", function(d){ return d.source.x})
      .attr("y1", function(d){ return d.source.y})
      .attr("x2", function(d){ return d.target.x})
      .attr("y2", function(d){ return d.target.y});

  //give the new links a corresponding line in the svg
  links.enter()
      .append("line")
      .attr("x1", function(d){ return d.source.x0})
      .attr("y1", function(d){ return d.source.y0})
      .attr("x2", function(d){ return d.source.x0})
      .attr("y2", function(d){ return d.source.y0})
      .transition().duration(500)
      .attr("x1", function(d){ return d.source.x})
      .attr("y1", function(d){ return d.source.y})
      .attr("x2", function(d){ return d.target.x})
      .attr("y2", function(d){ return d.target.y})

  //backup the current positions for animations
  nodes.each(function(d){
    d.x0 = d.x;
    d.y0 = d.y;
  });

  newNodes.each(function(d){
    d.x0 = d.x;
    d.y0 = d.y;
  });
}