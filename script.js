var body = document.getElementsByTagName("body")[0];
var width = body.scrollWidth, height = body.scrollHeight;
var treeSize = height > width ? width/2 - 100 : height/2 - 100;
var centerX = width/2, centerY = height / 2;
var previousK = 0;
var animationDuration = 400, zoomDuration = 150;
var nodeSize = Math.min(width/10, height/10);
var lineGenerator;
 // create an svg element and add it to the body
var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height);

// create group elements in the svg for links and nodes
var svgLinkGroup = svg.append("g");
var svgNodeGroup = svg.append("g");

// create a d3 hierarchy from the data generated by generateRandomTree()
var root = d3.stratify()
    .id(function(d) { return d.name; }) //tells d3 where to find the id for each node
    .parentId(function(d) { return d.parent; }) //tells d3 where to find the id for each nodes parent node
    (generateRandomTree()); //passes the data to create the tree from
var currentRoot = root;
currentRoot.x0 = width/2;
currentRoot.y0 = height/2;
// create a new d3 tree
var tree = d3.tree()
    .separation( //defines how far nodes should be apart from each other
      function separation(a, b) {
        return (a.parent == b.parent ? .4 : 2) / a.depth;
      });

//collapse the tree to only show the currentRoot and it's children
currentRoot.children.forEach(collapseAllChildren);

// tell the tree what data to use for it's nodes
updateTree();

//---------------------------------------//
// Functions
//---------------------------------------//

function generateRandomTree(){
  var nodes = [{"name" : "0", "parent": "", "type" : 0, "text" : "Node 1"}];
  var currentNode = 0, currentNeighbor = 1, neighborCount, currentType;
  while(nodes.length < 400){
    neighborCount = 1 + Math.round(Math.random()*4);
    for (var i = 0; i < neighborCount; i++) {
      currentType = Math.round(Math.random())
      nodes.push({"name" : ""+currentNeighbor++, "parent" : currentNode, "type" : currentType, "text" : "Node " + (currentNeighbor)});
    }
    currentNode++;
  }
  return nodes;
}

//calculates where to put each node using the layout d3 came up with as polar coordinates
function calculateCoordinates(){
  currentRoot.descendants().forEach(function(current){
    var x = current.x;
    var y = current.y;
    current.x = Math.cos(x*2*Math.PI) * y * treeSize + centerX,
    current.y = Math.sin(x*2*Math.PI) * y * treeSize + centerY;
  })
  currentRoot.x = centerX;
  currentRoot.y = centerY;
}

//updates all the nodes and links when a zoom event has occured (zoom events also happen when dragging the tree around)
function zoomed() {
  if (d3.event.transform.k != previousK) {
    //zoom behaviour
    svgNodeGroup.transition()
      .duration(zoomDuration)
      .attr("transform", d3.event.transform);
    svgLinkGroup.transition()
      .duration(zoomDuration)
      .attr("transform", d3.event.transform);
  } else {
    //drag behaviour
    svgNodeGroup.attr("transform", d3.event.transform);
    svgLinkGroup.attr("transform", d3.event.transform);
  }
  previousK = d3.event.transform.k;
}

function nodeClicked(node){
  if (node.children) {
    collapseSingleNode(node);
    if(node.parent) currentRoot = node.parent;
  } else {
    if (node.childrenBackup) {
      currentRoot = node;
      node.children = node.childrenBackup;
    } else {
      return;
    }
  }
  updateTree();
}

function collapseSingleNode(node){
  if (node.children) {
    node.childrenBackup = node.children;
    node.children = null;
  }
}

function collapseAllChildren(node){
  if (node.children) {
    node.children.forEach(collapseAllChildren);
    collapseSingleNode(node);
  }
}

function calculateTextSize(d){
  var boundingBox = this.getBBox();
  var parentBox = this.parentNode.getBBox();
  d.fontSize = Math.min(parentBox.width / boundingBox.width, parentBox.height / boundingBox.height)*0.8 + "px";
}

//creates a line using d3.line() according to the links source and target
//always creates lines so they are drawn from left to right which makes sure
//that any text along the line will not be upside down
function getLine(link){
  if(link.source.x <= link.target.x){
    return lineGenerator([[link.source.x, link.source.y],[link.target.x, link.target.y]]);
  } else {
    return lineGenerator([[link.target.x, link.target.y],[link.source.x, link.source.y]]);
  }
  
}

//decides the color of a node depending on its position in the tree
function getNodeColor(node){
  //leafs get white color
  if (!node.children && !node.childrenBackup) return "#fff";
  //the root gets red color
  if (node.id == currentRoot.id) return "#f00";
  //all other nodes get black color
  return "#000";
}

function updateTree(){

  //calculate a new layout for the tree
  tree(currentRoot);
  //convert coordinates of all nodes for radial layout
  calculateCoordinates();

  // add all the nodes from the tree as circles to the svg node Group
  var nodes = svgNodeGroup.selectAll("g").data(currentRoot.descendants(), function(d){return d.data.name});
  
  //transition existing nodes to their new positions
  nodes.transition()
      .duration(animationDuration)
      .attr("transform", function(d){
        return "translate(" + d.x + "," + d.y + ")"}
      )
      .attr("fill", getNodeColor);

  //get all the nodes that have been added to the tree
  var newNodes = nodes.enter().append("g");
  
  //nodes that weren't in the tree before get a shape in the svg according to their type
  var circleNodes = newNodes.filter(function(d, i, nodes){
    return d.data.type == 0;
  });
  var ellipseNodes = newNodes.filter(function(d, i, nodes){
    return d.data.type == 1;
  });
  ellipseNodes.insert("ellipse")
              .attr("rx", function(d){ 
                return nodeSize
              })
              .attr("ry", function(d){ 
                return nodeSize*0.6
              });
  circleNodes.insert("circle") 
            .attr("r", function(d){ 
              return nodeSize;
            });

  //nodes get text applied to them
  newNodes.insert("text")
          .text(function(d) {return d.data.text})
          .attr("text-anchor","middle")
          .attr("dominant-baseline", "central")
          .attr("font-size","1px")
          .each(calculateTextSize)
          .attr("font-size", function(d){return d.fontSize});

  //set the new nodes positions to their parents starting position
  newNodes.attr("transform", function(d){
    if(d.parent){
      d.x0 = d.parent.x;
      d.y0 = d.parent.y;
      return "translate(" + d.x0 + "," + d.y0 + ")";
    }
    else return "translate(" + d.x + "," + d.y + ")";
  })
  .attr("fill", getNodeColor)
  .attr("opacity", 0)
  //animate the node to go to it's correct position (starting from the parents previous position)
  .transition()
    .duration(animationDuration)
    .delay(animationDuration)
    .attr("transform", function(d){
      return "translate(" + d.x + "," + d.y + ")"}
    )
    .attr("opacity", 1);
  //remove nodes that aren't supposed to be shown anymore
  nodes.exit().remove();
  
  svgNodeGroup.selectAll("g").on("click", nodeClicked);

  // add all the links from the tree to the svg link group
  var links = svgLinkGroup.selectAll("g").data(currentRoot.links(), function(d){return d.target.id});
  
  //remove links that don't have a target anymore
  links.exit().remove();

  //create a new line generator
  if(!lineGenerator) lineGenerator = d3.line();

  //update existing links to their new coordinates
  links.transition().duration(animationDuration)
      .attr("d", getLine, lineGenerator, "asdf");//function(d){return lineGenerator([[d.source.x, d.source.y],[d.target.x, d.target.y]])});

  //give the new links a corresponding path in the svg and animate them
  var newPaths = links.enter().append("g");
  newPaths.insert("path")
      .attr("d", function(d){return lineGenerator([[d.source.x, d.source.y],[d.source.x, d.source.y]])})
      .attr("id", function(d){return d.source.id + "-" + d.target.id})
      .transition()
        .duration(animationDuration)
        .delay(animationDuration)
        .attr("d", getLine);
  
  var texts = newPaths.insert("text")
        .attr("text-anchor", "middle")
        .attr("font-size", 25)
        .attr("opacity", 0);
      texts.insert("textPath")
        .attr("xlink:href", function(d){return "#" + d.source.id + "-" + d.target.id})
        .attr("startOffset", "50%")
        .attr("alpha", 0)
        .text("supertext");
      texts.transition()
        .attr("opacity", 1)
        .delay(2*animationDuration)
        .duration(animationDuration);

  //backup the current positions for animations
  nodes.each(function(d){
    d.x0 = d.x;
    d.y0 = d.y;
  });

  newNodes.each(function(d){
    d.x0 = d.x;
    d.y0 = d.y;
  });
}